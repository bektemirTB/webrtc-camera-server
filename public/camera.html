<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ö–∞–º–µ—Ä–∞</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#4CAF50">
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #1a1a1a; color: white; margin: 0; }
    .screen { max-width: 600px; margin: 0 auto; }
    .hidden { display: none; }
    .pairing-code { font-size: 3rem; font-weight: bold; text-align: center; padding: 2rem; background: linear-gradient(135deg, #4CAF50, #45a049); border-radius: 12px; margin: 2rem 0; letter-spacing: 0.5rem; font-family: 'Courier New', monospace; position: relative; }
    .timer { font-size: 1rem; color: rgba(255,255,255,0.8); margin-top: 1rem; letter-spacing: normal; }
    .paired-info { background: #2d5016; padding: 1.5rem; border-radius: 8px; margin: 1rem 0; border: 2px solid #4CAF50; }
    .paired-info h3 { margin: 0 0 1rem 0; color: #4CAF50; }
    video { width: 100%; border: 2px solid #4CAF50; border-radius: 8px; background: black; }
    .status { margin: 10px 0; padding: 10px; background: #333; border-radius: 5px; }
    .connected { color: #4CAF50; } .disconnected { color: #f44336; } .waiting { color: #FFC107; }
    .settings { background: #333; padding: 1rem; border-radius: 8px; margin: 1rem 0; }
    .settings label { display: block; margin: 0.5rem 0; }
    .settings select, .settings input { padding: 0.5rem; background: #444; color: white; border: 1px solid #555; border-radius: 4px; width: 100%; max-width: 300px; }
    button { padding: 1rem 2rem; font-size: 1.1rem; border: none; border-radius: 8px; cursor: pointer; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; font-weight: 600; width: 100%; margin: 0.5rem 0; }
    button.secondary { background: linear-gradient(135deg, #666, #555); }
    button.danger { background: linear-gradient(135deg, #f44336, #d32f2f); }
    #log { max-height: 200px; overflow-y: auto; background: #222; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 11px; }
  </style>
</head>
<body>
  <div id="setupScreen" class="screen">
    <h1>üìπ –†–µ–∂–∏–º –ö–∞–º–µ—Ä—ã</h1>
    <div class="settings">
      <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞–º–µ—Ä—ã</h3>
      <label>–ö–∞—á–µ—Å—Ç–≤–æ –≤–∏–¥–µ–æ:
        <select id="qualitySelect">
          <option value="sd">SD (640x480)</option>
          <option value="hd" selected>HD (1280x720)</option>
          <option value="fullhd">Full HD (1920x1080)</option>
        </select>
      </label>
      <label>–í—ã–±–æ—Ä –∫–∞–º–µ—Ä—ã:
        <select id="cameraSelect">
          <option value="">–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞–º–µ—Ä...</option>
        </select>
      </label>
      <label><input type="checkbox" id="audioToggle" checked> –í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω</label>
    </div>
    <button onclick="checkPairAndStart()">üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
  </div>

  <div id="codeScreen" class="screen hidden">
    <h1>üîë –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä—ã</h1>
    <div class="pairing-code">
      <div id="pairingCode">----</div>
      <div class="timer" id="timer">–û—Å—Ç–∞–ª–æ—Å—å: 5:00</div>
    </div>
    <div class="status" id="codeStatus">
      <span class="waiting">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∑—Ä–∏—Ç–µ–ª—è...</span>
    </div>
    <p style="text-align: center; color: #999;">–ó—Ä–∏—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –≤–≤–µ—Å—Ç–∏ —ç—Ç–æ—Ç –∫–æ–¥ –≤ —Ç–µ—á–µ–Ω–∏–µ 5 –º–∏–Ω—É—Ç</p>
    <button class="secondary" onclick="cancelPairing()">‚ùå –û—Ç–º–µ–Ω–∞</button>
  </div>

  <div id="cameraScreen" class="screen hidden">
    <h1>üìπ –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞</h1>
    <div class="paired-info">
      <h3>‚úÖ –ü–∞—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞</h3>
      <p>–í–∞—à –∑—Ä–∏—Ç–µ–ª—å –º–æ–∂–µ—Ç –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è</p>
      <p><strong>ID –ø–∞—Ä—ã:</strong> <span id="pairId" style="font-family: monospace;">---</span></p>
    </div>

    <div class="status" id="status">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...</div>

    <video id="localVideo" autoplay playsinline muted></video>
    <audio id="remoteAudio" autoplay></audio>

    <div style="margin-top: 1rem;">
      <button class="secondary" onclick="stopCamera()">üõë –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
    </div>

    <div style="margin-top: 1rem;">
      <button class="danger break-button">üíî –†–∞–∑–æ—Ä–≤–∞—Ç—å –ø–∞—Ä—É</button>
    </div>

    <div id="log"></div>
  </div>

  <script>
    const socket = io("/", { transports: ['websocket', 'polling'] });

    const setupScreen = document.getElementById("setupScreen");
    const codeScreen = document.getElementById("codeScreen");
    const cameraScreen = document.getElementById("cameraScreen");
    const video = document.getElementById("localVideo");
    const remoteAudio = document.getElementById("remoteAudio");
    const statusDiv = document.getElementById("status");
    const codeStatusDiv = document.getElementById("codeStatus");
    const logDiv = document.getElementById("log");
    const pairingCodeDiv = document.getElementById("pairingCode");
    const timerDiv = document.getElementById("timer");
    const pairIdSpan = document.getElementById("pairId");
    const qualitySelect = document.getElementById("qualitySelect");
    const cameraSelect = document.getElementById("cameraSelect");
    const audioToggle = document.getElementById("audioToggle");
    const breakButton = document.querySelector(".break-button");

    let stream;
    let peerConnection;
    let pairedWith = null;
    let roomId = null;
    let timerInterval = null;
    let codeExpiresAt = null;

    const qualitySettings = {
      sd: { width: 640, height: 480 },
      hd: { width: 1280, height: 720 },
      fullhd: { width: 1920, height: 1080 }
    };

    function log(msg) {
      console.log(msg);
      const time = new Date().toLocaleTimeString();
      logDiv.innerHTML = `<div style="color: #888;">[${time}] ${msg}</div>` + logDiv.innerHTML;
    }

    function loadSavedPair() {
      const saved = localStorage.getItem('cameraPair');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          pairedWith = data.pairedWith;
          log("üíæ –ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–∞—è –ø–∞—Ä–∞: " + pairedWith);
          return true;
        } catch (e) {
          localStorage.removeItem('cameraPair');
        }
      }
      return false;
    }

    function savePair(viewerId) {
      localStorage.setItem('cameraPair', JSON.stringify({
        pairedWith: viewerId,
        createdAt: Date.now()
      }));
      log("üíæ –ü–∞—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞");
    }

    function clearPair() {
      localStorage.removeItem('cameraPair');
      pairedWith = null;
      roomId = null;
      log("üóë –ü–∞—Ä–∞ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ –ø–∞–º—è—Ç–∏");
    }

    async function checkPairAndStart() {
      if (loadSavedPair()) {
        log("üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ø–∞—Ä–æ–º...");
        socket.emit("restore-connection", { pairedWith });
      } else {
        await startCamera();
        showCodeScreen();
        socket.emit("generate-code");
      }
    }

    function showCodeScreen() {
      setupScreen.classList.add('hidden');
      codeScreen.classList.remove('hidden');
    }

    function cancelPairing() {
      if (timerInterval) clearInterval(timerInterval);
      stopCamera();
      codeScreen.classList.add('hidden');
      setupScreen.classList.remove('hidden');
    }

    function startTimer(expiresAt) {
      codeExpiresAt = expiresAt;

      timerInterval = setInterval(() => {
        const remaining = Math.max(0, codeExpiresAt - Date.now());
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);

        timerDiv.textContent = `–û—Å—Ç–∞–ª–æ—Å—å: ${minutes}:${seconds.toString().padStart(2, '0')}`;

        if (remaining <= 0) {
          clearInterval(timerInterval);
          codeStatusDiv.innerHTML = '<span class="disconnected">‚ùå –í—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ</span>';
          log("‚è∞ –í—Ä–µ–º—è –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞ –∏—Å—Ç–µ–∫–ª–æ");
        }
      }, 500);
    }

    // break button confirm + hold-to-break
    breakButton.addEventListener("click", () => {
      if (confirm("–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Ä–≤–∞—Ç—å –ø–∞—Ä—É? –ü—Ä–∏–¥–µ—Ç—Å—è —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–π –∫–æ–¥ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.")) {
        socket.emit("break-pair");
      }
    });
    let holdTimer;
    breakButton.addEventListener("mousedown", () => { holdTimer = setTimeout(() => socket.emit("break-pair"), 1000); });
    breakButton.addEventListener("mouseup", () => { clearTimeout(holdTimer); });
    breakButton.addEventListener("touchstart", () => { holdTimer = setTimeout(() => socket.emit("break-pair"), 1000); });
    breakButton.addEventListener("touchend", () => { clearTimeout(holdTimer); });

    async function loadCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter(d => d.kind === 'videoinput');

        cameraSelect.innerHTML = '';
        cameras.forEach((camera, index) => {
          const option = document.createElement('option');
          option.value = camera.deviceId;
          option.text = camera.label || `–ö–∞–º–µ—Ä–∞ ${index + 1}`;
          cameraSelect.appendChild(option);
        });

        log(`‚úÖ –ù–∞–π–¥–µ–Ω–æ –∫–∞–º–µ—Ä: ${cameras.length}`);
      } catch (err) {
        log("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞–º–µ—Ä: " + err.message);
      }
    }

    function getMediaConstraints() {
      const quality = qualitySettings[qualitySelect.value];
      const constraints = {
        video: {
          width: { ideal: quality.width },
          height: { ideal: quality.height },
          frameRate: { ideal: 30 }
        },
        audio: audioToggle.checked ? {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        } : false
      };

      if (cameraSelect.value) {
        constraints.video.deviceId = { exact: cameraSelect.value };
      }

      return constraints;
    }

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          await navigator.wakeLock.request('screen');
          log("üîì Wake Lock –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω");
        }
      } catch (err) {
        log("‚ùå –û—à–∏–±–∫–∞ Wake Lock: " + err.message);
      }
    }

    async function startCamera() {
      try {
        log("üì∑ –ó–∞–ø—Ä–∞—à–∏–≤–∞—é –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ...");
        const constraints = getMediaConstraints();

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        log("‚úÖ –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞");

        await requestWakeLock();

      } catch (err) {
        log("‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ: " + err.message);
        alert("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ: " + err.message);
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
        video.srcObject = null;
      }

      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }

      cameraScreen.classList.add('hidden');
      setupScreen.classList.remove('hidden');

      log("üõë –ö–∞–º–µ—Ä–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞");
    }

    async function createPeerConnection(targetId) {
      peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      // –ø—Ä–∏–∫—Ä–µ–ø–ª—è–µ–º —Å–≤–æ–∏ —Ç—Ä–µ–∫–∏ (–≤–∏–¥–µ–æ –∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω)
      if (stream) {
        stream.getTracks().forEach(track => {
          peerConnection.addTrack(track, stream);
        });
      }

      peerConnection.ontrack = e => {
        if (e.track.kind === 'audio') {
          // –ê—É–¥–∏–æ –æ—Ç –∑—Ä–∏—Ç–µ–ª—è (–º—ã —Å–ª—ã—à–∏–º –µ–≥–æ –≥–æ–ª–æ—Å)
          remoteAudio.srcObject = e.streams[0];
          log("üîä –ê—É–¥–∏–æ –æ—Ç –∑—Ä–∏—Ç–µ–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–æ");
        }
      };

      peerConnection.onicecandidate = e => {
        if (e.candidate) {
          socket.emit("ice-candidate", {
            candidate: {
              candidate: e.candidate.candidate,
              sdpMLineIndex: e.candidate.sdpMLineIndex,
              sdpMid: e.candidate.sdpMid
            },
            target: targetId
          });
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        log("üîó ICE: " + peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'connected') {
          statusDiv.innerHTML = '<span class="connected">‚úÖ –í–∏–¥–µ–æ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –∑—Ä–∏—Ç–µ–ª—é</span>';
        } else if (peerConnection.iceConnectionState === 'disconnected') {
          statusDiv.innerHTML = '<span class="disconnected">‚ö†Ô∏è –ó—Ä–∏—Ç–µ–ª—å –æ—Ç–∫–ª—é—á–∏–ª—Å—è</span>';
        }
      };

      try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        socket.emit("offer", {
          offer: { type: offer.type, sdp: offer.sdp },
          target: targetId
        });

        log("‚úÖ Offer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∑—Ä–∏—Ç–µ–ª—é");
      } catch (err) {
        log("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è offer: " + err.message);
      }
    }

    socket.on("connect", () => {
      log("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É: " + socket.id);
    });

    socket.on("code-generated", ({ code, expiresAt }) => {
      pairingCodeDiv.textContent = code;
      startTimer(expiresAt);
      log("üîë –ö–æ–¥ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω: " + code);
    });

    socket.on("code-expired", () => {
      codeStatusDiv.innerHTML = '<span class="disconnected">‚ùå –í—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ</span>';
      alert("–í—Ä–µ–º—è –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞ –∏—Å—Ç–µ–∫–ª–æ. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥.");
      cancelPairing();
    });

    socket.on("paired", async ({ pairedWith: viewerId, roomId: room }) => {
      pairedWith = viewerId;
      roomId = room;

      if (timerInterval) clearInterval(timerInterval);

      savePair(viewerId);

      pairIdSpan.textContent = viewerId.substring(0, 8);

      codeScreen.classList.add('hidden');
      cameraScreen.classList.remove('hidden');

      statusDiv.innerHTML = '<span class="connected">‚úÖ –ü–∞—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞! –û–∂–∏–¥–∞–Ω–∏–µ –∑—Ä–∏—Ç–µ–ª—è...</span>';
      log("‚úÖ –ü–∞—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞ —Å: " + viewerId);

      // –°–æ–∑–¥–∞–µ–º WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
      await createPeerConnection(viewerId);
    });

    socket.on("connection-restored", async ({ pairedWith: viewerId, roomId: room }) => {
      pairedWith = viewerId;
      roomId = room;

      pairIdSpan.textContent = viewerId.substring(0, 8);

      // –ü–æ–ø—ã—Ç–∞–µ–º—Å—è —Å—Ç–∞—Ä—Ç–æ–≤–∞—Ç—å –∫–∞–º–µ—Ä—É –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
      await startCamera();

      setupScreen.classList.add('hidden');
      cameraScreen.classList.remove('hidden');

      statusDiv.innerHTML = '<span class="connected">‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ</span>';
      log("‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Å: " + viewerId);

      await createPeerConnection(viewerId);
    });

    socket.on("wait-for-pair", ({ pairedWith: viewerId }) => {
      // –°–µ—Ä–≤–µ—Ä —Å–∫–∞–∑–∞–ª: –ø–æ–∫–∞ –ø–∞—Ä—ã –Ω–µ—Ç. –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ –∏ –∂–¥–µ–º –∑—Ä–∏—Ç–µ–ª—è.
      pairedWith = viewerId;
      savePair(viewerId);
      pairIdSpan.textContent = (viewerId || '---').substring(0, 8);
      codeScreen.classList.add('hidden');
      cameraScreen.classList.remove('hidden');
      statusDiv.innerHTML = '<span class="waiting">‚è≥ –ü–∞—Ä–∞ –æ–∂–∏–¥–∞–µ—Ç—Å—è. –ñ–¥–µ–º –∑—Ä–∏—Ç–µ–ª—è...</span>';
      log("‚è≥ –ü–∞—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ, –æ–∂–∏–¥–∞–µ–º –∑—Ä–∏—Ç–µ–ª—è");
    });

    socket.on("partner-online", () => {
      statusDiv.innerHTML = '<span class="connected">‚úÖ –ó—Ä–∏—Ç–µ–ª—å –æ–Ω–ª–∞–π–Ω</span>';
      log("üëÅ –ó—Ä–∏—Ç–µ–ª—å –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è");

      // –ê–≤—Ç–æ-–≤–∫–ª—é—á–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ WebRTC
      if (!stream) startCamera().then(() => {
        if (pairedWith) createPeerConnection(pairedWith);
      });
      else if (!peerConnection && pairedWith) createPeerConnection(pairedWith);
    });

    socket.on("partner-offline", () => {
      statusDiv.innerHTML = '<span class="disconnected">üì¥ –ó—Ä–∏—Ç–µ–ª—å –æ—Ñ–ª–∞–π–Ω</span>';
      log("üì¥ –ó—Ä–∏—Ç–µ–ª—å –æ—Ç–∫–ª—é—á–∏–ª—Å—è");

      // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É, –Ω–æ –Ω–µ —Ä–∞–∑—Ä—ã–≤–∞–µ–º –ø–∞—Ä—É –≤ –ø–∞–º—è—Ç–∏
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
        video.srcObject = null;
      }
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
    });

    socket.on("answer", async ({ answer }) => {
      if (peerConnection && answer) {
        try {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
          log("‚úÖ Answer –ø–æ–ª—É—á–µ–Ω");
        } catch (err) {
          log("‚ùå –û—à–∏–±–∫–∞ answer: " + err.message);
        }
      }
    });

    socket.on("ice-candidate", async ({ candidate }) => {
      if (peerConnection && candidate) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
          log("‚ùå –û—à–∏–±–∫–∞ ICE: " + err.message);
        }
      }
    });

    socket.on("pair-broken", () => {
      alert("–ü–∞—Ä–∞ —Ä–∞–∑–æ—Ä–≤–∞–Ω–∞. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.");
      clearPair();
      stopCamera();
    });

    socket.on("error", (msg) => {
      log("‚ùå –û—à–∏–±–∫–∞: " + msg);
      alert(msg);
      if (msg.includes("–∏—Å—Ç–µ–∫") || msg.includes("–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥")) {
        clearPair();
        cancelPairing();
      }
    });

    loadCameras();
  </script>
</body>
</html>
