<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ü—Ä–æ—Å–º–æ—Ç—Ä –∫–∞–º–µ—Ä—ã</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#2196F3">
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #1a1a1a;
      color: white;
      margin: 0;
    }
    .screen {
      max-width: 600px;
      margin: 0 auto;
    }
    .hidden { display: none; }
    
    .code-input {
      text-align: center;
      margin: 2rem 0;
    }
    
    .code-input input {
      font-size: 2.5rem;
      font-weight: bold;
      padding: 1rem 2rem;
      background: #333;
      border: 2px solid #2196F3;
      border-radius: 12px;
      color: white;
      text-align: center;
      letter-spacing: 0.5rem;
      font-family: 'Courier New', monospace;
      width: 100%;
      max-width: 300px;
    }
    
    .paired-info {
      background: #1a3a52;
      padding: 1.5rem;
      border-radius: 8px;
      margin: 1rem 0;
      border: 2px solid #2196F3;
    }
    
    .paired-info h3 {
      margin: 0 0 1rem 0;
      color: #2196F3;
    }
    
    video {
      width: 100%;
      min-height: 240px;
      border: 2px solid #2196F3;
      border-radius: 8px;
      background: black;
      display: block;
    }
    
    .status {
      margin: 10px 0;
      padding: 10px;
      background: #333;
      border-radius: 5px;
    }
    
    .connected { color: #4CAF50; }
    .disconnected { color: #f44336; }
    .waiting { color: #FFC107; }
    
    button {
      padding: 1rem 2rem;
      font-size: 1.1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: linear-gradient(135deg, #2196F3, #1976D2);
      color: white;
      font-weight: 600;
      width: 100%;
      margin: 0.5rem 0;
    }
    
    button:hover { opacity: 0.9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    button.secondary { background: linear-gradient(135deg, #666, #555); }
    button.danger { background: linear-gradient(135deg, #f44336, #d32f2f); }
    
    .voice-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin: 1rem 0;
    }
    
    .mic-button.active {
      background: linear-gradient(135deg, #f44336, #d32f2f);
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .instructions {
      background: #333;
      padding: 1.5rem;
      border-radius: 8px;
      margin: 1rem 0;
    }
    
    #log {
      max-height: 200px;
      overflow-y: auto;
      background: #222;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <!-- –≠–∫—Ä–∞–Ω –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–∞—Ä—ã -->
  <div id="checkScreen" class="screen">
    <h1>üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä –ö–∞–º–µ—Ä—ã</h1>
    
    <div class="instructions">
      <h3>–ó–∞–≥—Ä—É–∑–∫–∞...</h3>
      <p>–ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –ø–∞—Ä—É...</p>
    </div>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –≤–≤–æ–¥–∞ –∫–æ–¥–∞ -->
  <div id="codeScreen" class="screen hidden">
    <h1>üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä –ö–∞–º–µ—Ä—ã</h1>
    
    <div class="instructions">
      <h3>–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</h3>
      <p>–ü–æ–ª—É—á–∏—Ç–µ 4-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥ –æ—Ç –∫–∞–º–µ—Ä—ã. –ö–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 5 –º–∏–Ω—É—Ç.</p>
    </div>
    
    <div class="code-input">
      <input 
        type="text" 
        id="codeInput" 
        maxlength="4" 
        placeholder="0000"
        pattern="[0-9]*"
        inputmode="numeric"
      />
    </div>
    
    <button onclick="connectWithCode()" id="connectBtn">üîó –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ -->
  <div id="viewerScreen" class="screen hidden">
    <h1>üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä –∫–∞–º–µ—Ä—ã</h1>
    
    <div class="paired-info">
      <h3>‚úÖ –ü–∞—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞</h3>
      <p><strong>ID –∫–∞–º–µ—Ä—ã:</strong> <span id="pairId" style="font-family: monospace;">---</span></p>
      <button class="danger" onclick="confirmBreakPair()">üíî –†–∞–∑–æ—Ä–≤–∞—Ç—å –ø–∞—Ä—É</button>
    </div>
    
    <div class="status" id="status">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
    
    <video id="remoteVideo" autoplay playsinline controls></video>
    
    <div class="voice-controls">
      <button id="micButton" class="mic-button" onclick="toggleMicrophone()">
        üé§ –ì–æ–≤–æ—Ä–∏—Ç—å
      </button>
      <button onclick="toggleMute()">
        <span id="muteIcon">üîä</span> <span id="muteText">–ó–≤—É–∫</span>
      </button>
    </div>
    
    <div style="margin-top: 1rem;">
      <button class="secondary" onclick="disconnect()">‚ùå –û—Ç–∫–ª—é—á–∏—Ç—å—Å—è</button>
    </div>
    
    <div id="log"></div>
  </div>

  <script>
    const socket = io("https://webrtc-camera-server.onrender.com", {
      transports: ['websocket', 'polling']
    });
    
    const checkScreen = document.getElementById("checkScreen");
    const codeScreen = document.getElementById("codeScreen");
    const viewerScreen = document.getElementById("viewerScreen");
    const codeInput = document.getElementById("codeInput");
    const video = document.getElementById("remoteVideo");
    const statusDiv = document.getElementById("status");
    const logDiv = document.getElementById("log");
    const pairIdSpan = document.getElementById("pairId");
    const micButton = document.getElementById("micButton");
    const muteIcon = document.getElementById("muteIcon");
    const muteText = document.getElementById("muteText");
    
    let peerConnection;
    let localStream;
    let pairedWith = null;
    let roomId = null;
    let isMicActive = false;

    function log(msg) {
      console.log(msg);
      const time = new Date().toLocaleTimeString();
      logDiv.innerHTML = `<div style="color: #888;">[${time}] ${msg}</div>` + logDiv.innerHTML;
    }

    // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –ø–∞—Ä—ã
    function loadSavedPair() {
      const saved = localStorage.getItem('viewerPair');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          pairedWith = data.pairedWith;
          log("üíæ –ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–∞—è –ø–∞—Ä–∞: " + pairedWith);
          return true;
        } catch (e) {
          localStorage.removeItem('viewerPair');
        }
      }
      return false;
    }

    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–∞—Ä—ã
    function savePair(cameraId) {
      localStorage.setItem('viewerPair', JSON.stringify({
        pairedWith: cameraId,
        createdAt: Date.now()
      }));
      log("üíæ –ü–∞—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞");
    }

    // –£–¥–∞–ª–µ–Ω–∏–µ –ø–∞—Ä—ã
    function clearPair() {
      localStorage.removeItem('viewerPair');
      pairedWith = null;
      roomId = null;
      log("üóë –ü–∞—Ä–∞ —É–¥–∞–ª–µ–Ω–∞");
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    socket.on("connect", () => {
      log("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É: " + socket.id);
      
      if (loadSavedPair()) {
        log("üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...");
        socket.emit("restore-connection", { pairedWith });
      } else {
        log("üìù –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –ø–∞—Ä—ã");
        showCodeScreen();
      }
    });

    function showCodeScreen() {
      checkScreen.classList.add('hidden');
      codeScreen.classList.remove('hidden');
    }

    // –ê–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–¥–∞
    codeInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });

    codeInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && codeInput.value.length === 4) {
        connectWithCode();
      }
    });

    // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø–æ –∫–æ–¥—É
    function connectWithCode() {
      const code = codeInput.value.trim();
      
      if (code.length !== 4) {
        alert("–í–≤–µ–¥–∏—Ç–µ 4-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥");
        return;
      }
      
      log("üîë –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å –∫–æ–¥–æ–º: " + code);
      socket.emit("connect-with-code", { code });
      
      statusDiv.innerHTML = '<span class="waiting">‚è≥ –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä—ã...</span>';
    }

    // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–∞–∑—Ä—ã–≤–∞ –ø–∞—Ä—ã
    function confirmBreakPair() {
      if (confirm("–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Ä–≤–∞—Ç—å –ø–∞—Ä—É? –ü—Ä–∏–¥–µ—Ç—Å—è –≤–≤–æ–¥–∏—Ç—å –Ω–æ–≤—ã–π –∫–æ–¥ –æ—Ç –∫–∞–º–µ—Ä—ã.")) {
        socket.emit("break-pair");
      }
    }

    // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞
    async function toggleMicrophone() {
      if (!isMicActive) {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            } 
          });
          
          if (peerConnection) {
            localStream.getAudioTracks().forEach(track => {
              peerConnection.addTrack(track, localStream);
            });
            
            // Renegotiate
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit("offer", { 
              offer: { type: offer.type, sdp: offer.sdp },
              target: pairedWith
            });
          }
          
          isMicActive = true;
          micButton.classList.add('active');
          micButton.innerHTML = 'üî¥ –ì–æ–≤–æ—Ä—é...';
          log("‚úÖ –ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª—é—á–µ–Ω");
          
        } catch (err) {
          log("‚ùå –û—à–∏–±–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞: " + err.message);
          alert("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É");
        }
      } else {
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }
        
        isMicActive = false;
        micButton.classList.remove('active');
        micButton.innerHTML = 'üé§ –ì–æ–≤–æ—Ä–∏—Ç—å';
        log("üîá –ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª—é—á–µ–Ω");
      }
    }

    // –í–∫–ª/–≤—ã–∫–ª –∑–≤—É–∫–∞
    function toggleMute() {
      video.muted = !video.muted;
      if (video.muted) {
        muteIcon.textContent = 'üîá';
        muteText.textContent = '–ë–µ–∑ –∑–≤—É–∫–∞';
      } else {
        muteIcon.textContent = 'üîä';
        muteText.textContent = '–ó–≤—É–∫';
      }
    }

    // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ
    function disconnect() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      video.srcObject = null;
      
      viewerScreen.classList.add('hidden');
      checkScreen.classList.remove('hidden');
      
      isMicActive = false;
      micButton.classList.remove('active');
      micButton.innerHTML = 'üé§ –ì–æ–≤–æ—Ä–∏—Ç—å';
      
      log("‚ùå –û—Ç–∫–ª—é—á–µ–Ω–æ");
      
      // –ß–µ—Ä–µ–∑ —Å–µ–∫—É–Ω–¥—É –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä—É —Å–Ω–æ–≤–∞
      setTimeout(() => {
        if (loadSavedPair()) {
          socket.emit("restore-connection", { pairedWith });
        } else {
          showCodeScreen();
        }
      }, 1000);
    }

    // –°–æ–∑–¥–∞–Ω–∏–µ WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    async function createPeerConnection(targetId) {
      peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      peerConnection.ontrack = e => {
        log("üì∫ –¢—Ä–µ–∫ –ø–æ–ª—É—á–µ–Ω: " + e.track.kind);
        if (e.track.kind === 'video') {
          video.srcObject = e.streams[0];
          statusDiv.innerHTML = '<span class="connected">‚úÖ –í–∏–¥–µ–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è</span>';
        }
      };

      peerConnection.onicecandidate = e => {
        if (e.candidate) {
          socket.emit("ice-candidate", { 
            candidate: {
              candidate: e.candidate.candidate,
              sdpMLineIndex: e.candidate.sdpMLineIndex,
              sdpMid: e.candidate.sdpMid
            }, 
            target: targetId 
          });
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        log("üîó ICE: " + peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'failed') {
          statusDiv.innerHTML = '<span class="disconnected">‚ùå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å</span>';
        }
      };
    }

    // Socket —Å–æ–±—ã—Ç–∏—è
    socket.on("paired", async ({ pairedWith: cameraId, roomId: room }) => {
      pairedWith = cameraId;
      roomId = room;
      
      savePair(cameraId);
      
      pairIdSpan.textContent = cameraId.substring(0, 8);
      
      codeScreen.classList.add('hidden');
      checkScreen.classList.add('hidden');
      viewerScreen.classList.remove('hidden');
      
      statusDiv.innerHTML = '<span class="connected">‚úÖ –ü–∞—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞! –û–∂–∏–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã...</span>';
      log("‚úÖ –ü–∞—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞ —Å: " + cameraId);
      
      await createPeerConnection(cameraId);
    });

    socket.on("connection-restored", async ({ pairedWith: cameraId, roomId: room }) => {
      pairedWith = cameraId;
      roomId = room;
      
      pairIdSpan.textContent = cameraId.substring(0, 8);
      
      checkScreen.classList.add('hidden');
      codeScreen.classList.add('hidden');
      viewerScreen.classList.remove('hidden');
      
      statusDiv.innerHTML = '<span class="connected">‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ</span>';
      log("‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Å: " + cameraId);
      
      await createPeerConnection(cameraId);
    });

    socket.on("partner-online", () => {
      statusDiv.innerHTML = '<span class="connected">‚úÖ –ö–∞–º–µ—Ä–∞ –æ–Ω–ª–∞–π–Ω</span>';
      log("üìπ –ö–∞–º–µ—Ä–∞ –ø–æ–¥–∫–ª—é—á–∏–ª–∞—Å—å");
    });

    socket.on("partner-offline", () => {
      statusDiv.innerHTML = '<span class="disconnected">üì¥ –ö–∞–º–µ—Ä–∞ –æ—Ñ–ª–∞–π–Ω</span>';
      log("üì¥ –ö–∞–º–µ—Ä–∞ –æ—Ç–∫–ª—é—á–∏–ª–∞—Å—å");
    });

    socket.on("offer", async ({ offer }) => {
      log("üì• Offer –ø–æ–ª—É—á–µ–Ω");
      
      if (!peerConnection) {
        await createPeerConnection(pairedWith);
      }

      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        socket.emit("answer", { 
          answer: { type: answer.type, sdp: answer.sdp }, 
          target: pairedWith 
        });
        
        log("‚úÖ Answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω");
      } catch (err) {
        log("‚ùå –û—à–∏–±–∫–∞ WebRTC: " + err.message);
      }
    });

    socket.on("ice-candidate", async ({ candidate }) => {
      if (peerConnection && candidate) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
          log("‚ùå –û—à–∏–±–∫–∞ ICE: " + err.message);
        }
      }
    });

    socket.on("pair-broken", () => {
      alert("–ü–∞—Ä–∞ —Ä–∞–∑–æ—Ä–≤–∞–Ω–∞ –∫–∞–º–µ—Ä–æ–π.");
      clearPair();
      disconnect();
    });

    socket.on("error", (msg) => {
      log("‚ùå –û—à–∏–±–∫–∞: " + msg);
      alert(msg);
      
      if (msg.includes("–Ω–µ –Ω–∞–π–¥–µ–Ω–∞") || msg.includes("–∏—Å—Ç–µ–∫")) {
        clearPair();
        disconnect();
      }
    });

    video.onloadedmetadata = () => {
      log("üìπ –í–∏–¥–µ–æ: " + video.videoWidth + "x" + video.videoHeight);
    };
  </script>
</body>
</html>