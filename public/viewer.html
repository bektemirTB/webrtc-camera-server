<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ü—Ä–æ—Å–º–æ—Ç—Ä –∫–∞–º–µ—Ä—ã</title>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #1a1a1a;
      color: white;
    }
    video {
      width: 100%;
      max-width: 640px;
      border: 2px solid #2196F3;
      border-radius: 8px;
      background: black;
    }
    .status {
      margin: 10px 0;
      padding: 10px;
      background: #333;
      border-radius: 5px;
    }
    .connected { color: #4CAF50; }
    .disconnected { color: #f44336; }
    .waiting { color: #FFC107; }
    #log {
      max-height: 300px;
      overflow-y: auto;
      background: #222;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä –∫–∞–º–µ—Ä—ã</h1>
  <div class="status" id="status">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...</div>
  <video id="remoteVideo" autoplay playsinline></video>
  <div id="log"></div>

  <script>
    const socket = io("https://webrtc-camera-server.onrender.com", {
      transports: ['websocket', 'polling']
    });
    const roomId = "room1";
    const video = document.getElementById("remoteVideo");
    const statusDiv = document.getElementById("status");
    const logDiv = document.getElementById("log");
    let peer;
    let iceCandidatesQueue = []; // –ë—É—Ñ–µ—Ä –¥–ª—è ICE candidates
    let iceSentCount = 0;
    let iceReceivedCount = 0;

    function log(msg) {
      console.log(msg);
      const time = new Date().toLocaleTimeString();
      logDiv.innerHTML = `<div style="color: #888;">[${time}] ${msg}</div>` + logDiv.innerHTML;
    }

    socket.on("connect", () => {
      log("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É, Socket ID: " + socket.id);
      statusDiv.innerHTML = '<span class="connected">‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É</span>';
      socket.emit("join-room", { roomId, role: "viewer" });
      log("üì° –û—Ç–ø—Ä–∞–≤–ª–µ–Ω join-room —Å —Ä–æ–ª—å—é viewer");
      statusDiv.innerHTML = '<span class="waiting">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã...</span>';
    });

    socket.on("disconnect", () => {
      log("‚ùå –û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞");
      statusDiv.innerHTML = '<span class="disconnected">‚ùå –û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞</span>';
    });

    socket.on("offer", async (data) => {
      log("üì• –°–æ–±—ã—Ç–∏–µ offer –ø–æ–ª—É—á–µ–Ω–æ");
      log("üìä –î–∞–Ω–Ω—ã–µ: " + JSON.stringify(Object.keys(data)));
      
      // –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö
      if (!data) {
        log("‚ùå data –≤–æ–æ–±—â–µ –Ω–µ—Ç!");
        console.error("‚ùå data is null/undefined");
        return;
      }

      const { offer, target } = data;
      
      log("üìä offer —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: " + (!!offer));
      log("üìä target: " + target);
      
      if (!offer) {
        log("‚ùå –ü–æ–ª—É—á–µ–Ω –ø—É—Å—Ç–æ–π offer!");
        log("‚ùå –ü–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è: " + JSON.stringify(data));
        console.error("‚ùå –ü–æ–ª—É—á–µ–Ω –ø—É—Å—Ç–æ–π offer, –¥–∞–Ω–Ω—ã–µ:", data);
        return;
      }

      if (!offer.sdp) {
        log("‚ùå Offer –±–µ–∑ SDP!");
        log("‚ùå Offer: " + JSON.stringify(offer));
        console.error("‚ùå Offer –±–µ–∑ SDP:", offer);
        return;
      }

      log("‚úÖ Offer –≤–∞–ª–∏–¥–Ω—ã–π, —Ç–∏–ø: " + offer.type + ", –¥–ª–∏–Ω–∞ SDP: " + offer.sdp.length);

      try {
        // –°–æ–∑–¥–∞—ë–º PeerConnection
        log("üîÑ –°–æ–∑–¥–∞—é PeerConnection");
        peer = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        });

        // –ü–æ–ª—É—á–∞–µ–º –≤–∏–¥–µ–æ —Ç—Ä–µ–∫
        peer.ontrack = e => {
          log("üì∫ –í–∏–¥–µ–æ —Ç—Ä–µ–∫ –ø–æ–ª—É—á–µ–Ω! Streams: " + e.streams.length);
          video.srcObject = e.streams[0];
          statusDiv.innerHTML = '<span class="connected">‚úÖ –í–∏–¥–µ–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è</span>';
        };

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã
        peer.onicecandidate = e => {
          if (e.candidate) {
            log("üßä ICE –∫–∞–Ω–¥–∏–¥–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫–∞–º–µ—Ä–µ");
            socket.emit("ice-candidate", { 
              candidate: {
                candidate: e.candidate.candidate,
                sdpMLineIndex: e.candidate.sdpMLineIndex,
                sdpMid: e.candidate.sdpMid
              }, 
              target 
            });
          }
        };

        peer.oniceconnectionstatechange = () => {
          log("üîó ICE —Å–æ—Å—Ç–æ—è–Ω–∏–µ: " + peer.iceConnectionState);
          if (peer.iceConnectionState === 'connected') {
            statusDiv.innerHTML = '<span class="connected">‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ</span>';
          } else if (peer.iceConnectionState === 'failed') {
            log("‚ùå ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å");
            statusDiv.innerHTML = '<span class="disconnected">‚ùå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å</span>';
          } else if (peer.iceConnectionState === 'disconnected') {
            log("‚ö†Ô∏è ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ");
            statusDiv.innerHTML = '<span class="disconnected">‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ</span>';
          }
        };

        peer.onconnectionstatechange = () => {
          log("üîó Connection —Å–æ—Å—Ç–æ—è–Ω–∏–µ: " + peer.connectionState);
        };

        peer.onicegatheringstatechange = () => {
          log("üßä ICE gathering —Å–æ—Å—Ç–æ—è–Ω–∏–µ: " + peer.iceGatheringState);
        };

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º remote description
        log("üîÑ –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é remote description");
        await peer.setRemoteDescription(new RTCSessionDescription(offer));
        log("‚úÖ Remote description —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–µ ICE candidates
        if (iceCandidatesQueue.length > 0) {
          log(`üì¶ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é ${iceCandidatesQueue.length} –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö ICE candidates`);
          for (const candidate of iceCandidatesQueue) {
            try {
              await peer.addIceCandidate(new RTCIceCandidate(candidate));
              log("‚úÖ –ù–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–π ICE candidate –¥–æ–±–∞–≤–ª–µ–Ω");
            } catch (err) {
              log("‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–æ–≥–æ ICE: " + err.message);
            }
          }
          iceCandidatesQueue = [];
        }

        // –°–æ–∑–¥–∞—ë–º answer
        log("üîÑ –°–æ–∑–¥–∞—é answer");
        const answer = await peer.createAnswer();
        await peer.setLocalDescription(answer);
        
        log("‚úÖ Answer —Å–æ–∑–¥–∞–Ω, —Ç–∏–ø: " + answer.type + ", –¥–ª–∏–Ω–∞ SDP: " + answer.sdp.length);
        log("üì° –û—Ç–ø—Ä–∞–≤–ª—è—é answer –∫–∞–º–µ—Ä–µ, target: " + target);
        
        socket.emit("answer", { 
          answer: {
            type: answer.type,
            sdp: answer.sdp
          }, 
          target 
        });
        log("‚úÖ Answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω");

        statusDiv.innerHTML = '<span class="waiting">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ...</span>';
      } catch (err) {
        log("‚ùå –û—à–∏–±–∫–∞ WebRTC: " + err.message);
        console.error("‚ùå –û—à–∏–±–∫–∞ WebRTC:", err);
        statusDiv.innerHTML = '<span class="disconnected">‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è</span>';
      }
    });

    socket.on("ice-candidate", async ({ candidate, target }) => {
      log("üßä ICE –∫–∞–Ω–¥–∏–¥–∞—Ç –ø–æ–ª—É—á–µ–Ω –æ—Ç –∫–∞–º–µ—Ä—ã");
      
      if (!candidate) {
        log("‚ùå candidate –ø—É—Å—Ç–æ–π");
        return;
      }

      // –ï—Å–ª–∏ peer –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–Ω –∏–ª–∏ remote description –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å
      if (!peer || !peer.remoteDescription) {
        log("üì¶ Peer –Ω–µ –≥–æ—Ç–æ–≤, –¥–æ–±–∞–≤–ª—è—é candidate –≤ –æ—á–µ—Ä–µ–¥—å");
        iceCandidatesQueue.push(candidate);
        return;
      }
      
      // –ò–Ω–∞—á–µ —Å—Ä–∞–∑—É –¥–æ–±–∞–≤–ª—è–µ–º
      try {
        await peer.addIceCandidate(new RTCIceCandidate(candidate));
        log("‚úÖ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç –¥–æ–±–∞–≤–ª–µ–Ω");
      } catch (err) {
        log("‚ùå –û—à–∏–±–∫–∞ ICE: " + err.message);
        console.error("–û—à–∏–±–∫–∞ ICE:", err);
      }
    });

    socket.on("camera-disconnected", () => {
      log("‚ùå –ö–∞–º–µ—Ä–∞ –æ—Ç–∫–ª—é—á–∏–ª–∞—Å—å");
      statusDiv.innerHTML = '<span class="disconnected">‚ùå –ö–∞–º–µ—Ä–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞</span>';
      video.srcObject = null;
      if (peer) {
        peer.close();
        peer = null;
      }
    });

    socket.on("error", (error) => {
      log("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∫–µ—Ç–∞: " + JSON.stringify(error));
      console.error("Socket error:", error);
    });

    // –û—Ç–ª–∞–¥–∫–∞: —Å–ª—É—à–∞–µ–º –≤—Å–µ —Å–æ–±—ã—Ç–∏—è
    socket.onAny((eventName, ...args) => {
      log("üì® –°–æ–±—ã—Ç–∏–µ –ø–æ–ª—É—á–µ–Ω–æ: " + eventName);
      if (eventName === "offer") {
        log("üìä Offer args length: " + args.length);
        if (args[0]) {
          log("üìä Offer args[0] keys: " + Object.keys(args[0]).join(", "));
        }
      }
    });
  </script>
</body>
</html>