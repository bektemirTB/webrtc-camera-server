<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ü—Ä–æ—Å–º–æ—Ç—Ä –∫–∞–º–µ—Ä—ã</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#2196F3">
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #1a1a1a;
      color: white;
      margin: 0;
      padding-bottom: 100px;
    }
    .screen {
      max-width: 600px;
      margin: 0 auto;
    }
    .hidden { display: none; }
    
    .code-input {
      text-align: center;
      margin: 2rem 0;
    }
    
    .code-input input {
      font-size: 2.5rem;
      font-weight: bold;
      padding: 1rem 2rem;
      background: #333;
      border: 2px solid #2196F3;
      border-radius: 12px;
      color: white;
      text-align: center;
      letter-spacing: 0.5rem;
      font-family: 'Courier New', monospace;
      width: 100%;
      max-width: 300px;
    }
    
    .paired-info {
      background: #1a3a52;
      padding: 1.5rem;
      border-radius: 8px;
      margin: 1rem 0;
      border: 2px solid #2196F3;
    }
    
    video {
      width: 100%;
      min-height: 240px;
      border: 2px solid #2196F3;
      border-radius: 8px;
      background: black;
      display: block;
    }
    
    .status {
      margin: 10px 0;
      padding: 10px;
      background: #333;
      border-radius: 5px;
    }
    
    .connected { color: #4CAF50; }
    .disconnected { color: #f44336; }
    .waiting { color: #FFC107; }
    
    button {
      padding: 1rem 2rem;
      font-size: 1.1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: linear-gradient(135deg, #2196F3, #1976D2);
      color: white;
      font-weight: 600;
      width: 100%;
      margin: 0.5rem 0;
    }
    
    button:hover { opacity: 0.9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    button.secondary { background: linear-gradient(135deg, #666, #555); }
    button.danger { 
      background: linear-gradient(135deg, #f44336, #d32f2f);
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      max-width: 560px;
      margin: 0 auto;
      z-index: 1000;
    }
    
    .voice-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin: 1rem 0;
    }
    
    .mic-button.active {
      background: linear-gradient(135deg, #f44336, #d32f2f);
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .instructions {
      background: #333;
      padding: 1.5rem;
      border-radius: 8px;
      margin: 1rem 0;
    }
    
    #log {
      max-height: 150px;
      overflow-y: auto;
      background: #222;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <!-- –≠–∫—Ä–∞–Ω –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–∞—Ä—ã -->
  <div id="checkScreen" class="screen">
    <h1>üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä</h1>
    <div class="instructions">
      <h3>–ó–∞–≥—Ä—É–∑–∫–∞...</h3>
      <p>–ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –ø–∞—Ä—É...</p>
    </div>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –≤–≤–æ–¥–∞ –∫–æ–¥–∞ -->
  <div id="codeScreen" class="screen hidden">
    <h1>üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä</h1>
    
    <div class="instructions">
      <h3>–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</h3>
      <p>–ü–æ–ª—É—á–∏—Ç–µ 4-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥ –æ—Ç –∫–∞–º–µ—Ä—ã. –ö–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 5 –º–∏–Ω—É—Ç.</p>
    </div>
    
    <div class="code-input">
      <input 
        type="text" 
        id="codeInput" 
        maxlength="4" 
        placeholder="0000"
        pattern="[0-9]*"
        inputmode="numeric"
      />
    </div>
    
    <button onclick="connectWithCode()" id="connectBtn">üîó –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ -->
  <div id="viewerScreen" class="screen hidden">
    <h1>üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä</h1>
    
    <div class="paired-info">
      <h3>‚úÖ –ü–∞—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞</h3>
      <div class="status" id="cameraStatus">
        <span class="disconnected">üì¥ –ö–∞–º–µ—Ä–∞ –æ—Ñ–ª–∞–π–Ω</span>
      </div>
    </div>
    
    <div class="status" id="status">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
    
    <video id="remoteVideo" autoplay playsinline controls></video>
    
    <!-- –°–∫—Ä—ã—Ç–æ–µ –∞—É–¥–∏–æ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≥–æ–ª–æ—Å–∞ –Ω–∞ –∫–∞–º–µ—Ä—É -->
    <audio id="localAudio" style="display: none;"></audio>
    
    <div class="voice-controls">
      <button id="micButton" class="mic-button" onclick="toggleMicrophone()">
        üé§ –ì–æ–≤–æ—Ä–∏—Ç—å
      </button>
      <button onclick="toggleMute()">
        <span id="muteIcon">üîä</span> <span id="muteText">–ó–≤—É–∫</span>
      </button>
    </div>
    
    <div id="log"></div>
    
    <button class="danger" onclick="confirmBreakPair()">üíî –†–∞–∑–æ—Ä–≤–∞—Ç—å –ø–∞—Ä—É</button>
  </div>

  <script>
    const socket = io("https://webrtc-camera-server.onrender.com", {
      transports: ['websocket', 'polling']
    });
    
    const checkScreen = document.getElementById("checkScreen");
    const codeScreen = document.getElementById("codeScreen");
    const viewerScreen = document.getElementById("viewerScreen");
    const codeInput = document.getElementById("codeInput");
    const video = document.getElementById("remoteVideo");
    const localAudio = document.getElementById("localAudio");
    const statusDiv = document.getElementById("status");
    const cameraStatusDiv = document.getElementById("cameraStatus");
    const logDiv = document.getElementById("log");
    const micButton = document.getElementById("micButton");
    const muteIcon = document.getElementById("muteIcon");
    const muteText = document.getElementById("muteText");
    
    let peerConnection;
    let localStream;
    let pairedWith = null;
    let myOriginalId = null;
    let isMicActive = false;
    let isCameraOnline = false;

    function log(msg) {
      console.log(msg);
      const time = new Date().toLocaleTimeString();
      logDiv.innerHTML = `<div style="color: #888;">[${time}] ${msg}</div>` + logDiv.innerHTML;
    }

    function getOrCreateOriginalId() {
      let id = localStorage.getItem('viewerOriginalId');
      if (!id) {
        id = 'view_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        localStorage.setItem('viewerOriginalId', id);
        log("üÜî –°–æ–∑–¥–∞–Ω ID: " + id);
      } else {
        log("üÜî –ó–∞–≥—Ä—É–∂–µ–Ω ID: " + id);
      }
      return id;
    }

    function loadSavedPair() {
      const saved = localStorage.getItem('viewerPair');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          pairedWith = data.pairedWith;
          log("üíæ –ó–∞–≥—Ä—É–∂–µ–Ω–∞ –ø–∞—Ä–∞: " + pairedWith);
          return true;
        } catch (e) {
          localStorage.removeItem('viewerPair');
        }
      }
      return false;
    }

    function savePair(cameraId) {
      localStorage.setItem('viewerPair', JSON.stringify({
        pairedWith: cameraId,
        createdAt: Date.now()
      }));
      log("üíæ –ü–∞—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞");
    }

    function clearPair() {
      localStorage.removeItem('viewerPair');
      pairedWith = null;
      log("üóë –ü–∞—Ä–∞ —É–¥–∞–ª–µ–Ω–∞");
    }

    function showCodeScreen() {
      checkScreen.classList.add('hidden');
      codeScreen.classList.remove('hidden');
    }

    function showViewerScreen() {
      checkScreen.classList.add('hidden');
      codeScreen.classList.add('hidden');
      viewerScreen.classList.remove('hidden');
    }

    codeInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });

    codeInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && codeInput.value.length === 4) {
        connectWithCode();
      }
    });

    function connectWithCode() {
      const code = codeInput.value.trim();
      
      if (code.length !== 4) {
        alert("–í–≤–µ–¥–∏—Ç–µ 4-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥");
        return;
      }
      
      log("üîë –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å –∫–æ–¥–æ–º: " + code);
      socket.emit("connect-with-code", { code, originalId: myOriginalId });
      
      statusDiv.innerHTML = '<span class="waiting">‚è≥ –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä—ã...</span>';
    }

    function confirmBreakPair() {
      if (confirm("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï!\n\n–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Ä–≤–∞—Ç—å –ø–∞—Ä—É?\n\n–ü–æ—Å–ª–µ —Ä–∞–∑—Ä—ã–≤–∞ –≤–∞–º –ø—Ä–∏–¥–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å –Ω–æ–≤—ã–π –∫–æ–¥ –æ—Ç –∫–∞–º–µ—Ä—ã –∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –¥–æ–º–æ–π –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.\n\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?")) {
        socket.emit("break-pair", { originalId: myOriginalId });
      }
    }

    async function toggleMicrophone() {
      if (!isMicActive) {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            } 
          });
          
          // –î–æ–±–∞–≤–ª—è–µ–º –∞—É–¥–∏–æ —Ç—Ä–µ–∫ –≤ peerConnection
          if (peerConnection) {
            const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'audio');
            
            if (sender) {
              // –ó–∞–º–µ–Ω—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ç—Ä–µ–∫
              await sender.replaceTrack(localStream.getAudioTracks()[0]);
              log("üé§ –ê—É–¥–∏–æ —Ç—Ä–µ–∫ –∑–∞–º–µ–Ω–µ–Ω");
            } else {
              // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —Ç—Ä–µ–∫
              localStream.getAudioTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
                log("üé§ –ê—É–¥–∏–æ —Ç—Ä–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω");
              });
              
              // Renegotiate
              const offer = await peerConnection.createOffer();
              await peerConnection.setLocalDescription(offer);
              socket.emit("offer", { 
                offer: { type: offer.type, sdp: offer.sdp },
                originalId: myOriginalId
              });
              log("üîÑ Renegotiate –¥–ª—è –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞");
            }
          }
          
          isMicActive = true;
          micButton.classList.add('active');
          micButton.innerHTML = 'üî¥ –ì–æ–≤–æ—Ä—é...';
          log("‚úÖ –ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª—é—á–µ–Ω - –≥–æ–ª–æ—Å –∏–¥–µ—Ç –Ω–∞ –∫–∞–º–µ—Ä—É");
          
        } catch (err) {
          log("‚ùå –ú–∏–∫—Ä–æ—Ñ–æ–Ω: " + err.message);
          alert("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É");
        }
      } else {
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          
          // –£–¥–∞–ª—è–µ–º —Ç—Ä–µ–∫ –∏–∑ peerConnection
          if (peerConnection) {
            const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'audio');
            if (sender) {
              peerConnection.removeTrack(sender);
              log("üîá –ê—É–¥–∏–æ —Ç—Ä–µ–∫ —É–¥–∞–ª–µ–Ω");
            }
          }
          
          localStream = null;
        }
        
        isMicActive = false;
        micButton.classList.remove('active');
        micButton.innerHTML = 'üé§ –ì–æ–≤–æ—Ä–∏—Ç—å';
        log("üîá –ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª—é—á–µ–Ω");
      }
    }

    function toggleMute() {
      video.muted = !video.muted;
      if (video.muted) {
        muteIcon.textContent = 'üîá';
        muteText.textContent = '–ë–µ–∑ –∑–≤—É–∫–∞';
      } else {
        muteIcon.textContent = 'üîä';
        muteText.textContent = '–ó–≤—É–∫';
      }
    }

    function disconnect() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      video.srcObject = null;
      
      isMicActive = false;
      micButton.classList.remove('active');
      micButton.innerHTML = 'üé§ –ì–æ–≤–æ—Ä–∏—Ç—å';
      
      viewerScreen.classList.add('hidden');
      checkScreen.classList.remove('hidden');
      
      log("‚ùå –û—Ç–∫–ª—é—á–µ–Ω–æ");
      
      setTimeout(() => {
        if (loadSavedPair()) {
          socket.emit("restore-connection", { originalId: myOriginalId, role: "viewer" });
        } else {
          showCodeScreen();
        }
      }, 1000);
    }

    async function createPeerConnection() {
      if (peerConnection) {
        peerConnection.close();
      }

      peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      peerConnection.ontrack = e => {
        log("üì∫ –¢—Ä–µ–∫: " + e.track.kind);
        if (e.track.kind === 'video') {
          video.srcObject = e.streams[0];
          statusDiv.innerHTML = '<span class="connected">‚úÖ –í–∏–¥–µ–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è</span>';
        }
      };

      peerConnection.onicecandidate = e => {
        if (e.candidate) {
          socket.emit("ice-candidate", { 
            candidate: {
              candidate: e.candidate.candidate,
              sdpMLineIndex: e.candidate.sdpMLineIndex,
              sdpMid: e.candidate.sdpMid
            }, 
            originalId: myOriginalId 
          });
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        log("üîó ICE: " + peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'failed') {
          statusDiv.innerHTML = '<span class="disconnected">‚ùå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å</span>';
        }
      };
    }

    // Socket —Å–æ–±—ã—Ç–∏—è
    socket.on("connect", () => {
      myOriginalId = getOrCreateOriginalId();
      socket.emit("register", { originalId: myOriginalId, role: "viewer" });
      log("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ: " + socket.id);
      
      if (loadSavedPair()) {
        log("üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ä—ã...");
        socket.emit("restore-connection", { originalId: myOriginalId, role: "viewer" });
      } else {
        log("üìù –ù–µ—Ç –ø–∞—Ä—ã");
        showCodeScreen();
      }
    });

    socket.on("paired", async ({ pairedWith: cameraId, cameraOnline }) => {
      pairedWith = cameraId;
      
      savePair(cameraId);
      
      showViewerScreen();
      
      if (cameraOnline) {
        cameraStatusDiv.innerHTML = '<span class="connected">‚úÖ –ö–∞–º–µ—Ä–∞ –æ–Ω–ª–∞–π–Ω</span>';
        isCameraOnline = true;
        await createPeerConnection();
      } else {
        cameraStatusDiv.innerHTML = '<span class="disconnected">üì¥ –ö–∞–º–µ—Ä–∞ –æ—Ñ–ª–∞–π–Ω</span>';
        isCameraOnline = false;
        statusDiv.innerHTML = '<span class="waiting">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã...</span>';
      }
      
      log("‚úÖ –ü–∞—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞: " + cameraId);
    });

    socket.on("connection-restored", async ({ pairedWith: cameraId }) => {
      pairedWith = cameraId;
      
      showViewerScreen();
      cameraStatusDiv.innerHTML = '<span class="waiting">‚è≥ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–º–µ—Ä—ã...</span>';
      
      log("‚úÖ –ü–∞—Ä–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: " + cameraId);
    });

    socket.on("camera-online", async () => {
      cameraStatusDiv.innerHTML = '<span class="connected">‚úÖ –ö–∞–º–µ—Ä–∞ –æ–Ω–ª–∞–π–Ω</span>';
      isCameraOnline = true;
      log("üìπ –ö–∞–º–µ—Ä–∞ –æ–Ω–ª–∞–π–Ω");
      
      await createPeerConnection();
    });

    socket.on("camera-offline", () => {
      cameraStatusDiv.innerHTML = '<span class="disconnected">üì¥ –ö–∞–º–µ—Ä–∞ –æ—Ñ–ª–∞–π–Ω</span>';
      isCameraOnline = false;
      statusDiv.innerHTML = '<span class="waiting">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã...</span>';
      
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      
      log("üì¥ –ö–∞–º–µ—Ä–∞ –æ—Ñ–ª–∞–π–Ω");
    });

    socket.on("offer", async ({ offer }) => {
      log("üì• Offer –ø–æ–ª—É—á–µ–Ω");
      
      if (!peerConnection) {
        await createPeerConnection();
      }

      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        socket.emit("answer", { 
          answer: { type: answer.type, sdp: answer.sdp }, 
          originalId: myOriginalId 
        });
        
        log("‚úÖ Answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω");
      } catch (err) {
        log("‚ùå WebRTC: " + err.message);
      }
    });

    socket.on("ice-candidate", async ({ candidate }) => {
      if (peerConnection && candidate) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
          log("‚ùå ICE: " + err.message);
        }
      }
    });

    socket.on("pair-broken", () => {
      alert("–ü–∞—Ä–∞ —Ä–∞–∑–æ—Ä–≤–∞–Ω–∞.");
      clearPair();
      disconnect();
    });

    socket.on("error", (msg) => {
      log("‚ùå " + msg);
      if (msg.includes("–Ω–µ –Ω–∞–π–¥–µ–Ω–∞") || msg.includes("–ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∞")) {
        clearPair();
        alert(msg + "\n\n–°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—É—é –ø–∞—Ä—É.");
        disconnect();
      } else {
        alert(msg);
      }
    });

    video.onloadedmetadata = () => {
      log("üìπ –í–∏–¥–µ–æ: " + video.videoWidth + "x" + video.videoHeight);
    };
  </script>
</body>
</html>